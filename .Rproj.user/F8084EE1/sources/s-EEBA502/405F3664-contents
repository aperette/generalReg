likelihood_ratio <- function(x, parameters,correction=FALSE){
  loglike=function(y,media,var){
    -0.5*sum(log(var)) -0.5*sum(((media-y)^2)/var)}
  theta=coef(x) %>% data.frame(nome=names(.),valor=.) %>% tidyr::spread(nome,valor)
  par_teste = dplyr::bind_rows(theta,parameters) %>% dplyr::summarise_all(funs(tail(na.omit(.),1)))
  p=length(theta)
  q=length(parameters)
  data=x$data
  
  mu=x$fitted.values
  var=Matrix::diag(x$var)
  mu0=x$function_mu(par_teste,x$data)
  var0=Matrix::diag(x$function_sigma(par_teste,x$data))
  y=x$target
  
  l1=loglike(y,mu,var)
  l0=loglike(y,mu0,var0)
  
  LR=2*(l1-l0)
  pv=pchisq(LR,df = q,lower.tail = F)
  
  if(correction==FALSE){return(list(LR=LR,p.value=pv))}
  
  ####Skovgaard correction:
  z=x$target-x$fitted.values
  z0=z+mu-mu0
  z0=x$target-mu0
  u0=(z0^2)/var0
  P=sqrt(var)
  P0=Matrix::diag(x$function_sigma(par_teste,x$data))^0.5
  Pd=0.5*diag(1/sqrt(var))%*%x$function_V(theta,data)
  a=(y-x$fitted.values)/P
  u00=(a^2)*(P0^2)/var0
  
  T=x$function_D(theta,data)+z*x$function_V(theta,data)/var
  T00=x$function_D(par_teste,data)+a*P0*x$function_V(par_teste,data)/var0
  
  B=-z*x$function_D(theta,data) -0.5*x$function_V(theta,data)
  B00=-z0*x$function_D(par_teste,data) -0.5*x$function_V(par_teste,data)
  A=-x$function_V(theta,data)/var^2
  A0=-x$function_V(par_teste,data)/var0^2
  
  aux1=rep(1:length(theta),length(theta))
  aux2=rep(1:length(theta),each=length(theta))
  Ad = -2*A[,aux1]*x$function_V(theta,data)[,aux2]/var
  Ad = Ad - x$function_C(theta,data)/var^2
  Ad0 = -2*A0[,aux1]*x$function_V(par_teste,data)[,aux2]/var0
  Ad0 = Ad0 - x$function_C(par_teste,data)/var0^2
  
  E = -0.5*(Ad*(var-z^2)) - x$function_D2(theta,data)*z/var
  E00 = -0.5*(Ad0*(var0-(a*P0)^2)) - x$function_D2(par_teste,data)*a*P0/var0
  G = apply(B[,aux1]*A[,aux2] + E,2,sum) %>% matrix(nrow=length(theta))
  G00 = apply(B00[,aux1]*A0[,aux2] + E00,2,sum) %>% matrix(nrow=length(theta))
  
  R = Pd*a + x$function_D(theta,data)
  
  Q = x$function_D(theta,data)+z*x$function_V(theta,data)/var
  Q00 = x$function_D(par_teste,data)+z0*x$function_V(par_teste,data)/var0
  
  Ud0 = Matrix::t(Q00/var0)%*%R
  U0= Matrix::t(x$function_F(par_teste,data)) %*% x$function_H(x$function_sigma(par_teste,data)) %*% x$function_s(mu0,x$function_sigma(par_teste,data),par_teste,all = F)
  J00 = Matrix::t(T00/var0)%*%x$function_D(par_teste,data) + G00
  J = Matrix::t(T)%*%solve(x$var)%*%x$function_D(theta,data) + G
  
  ld = Matrix::t(R/var)%*%(-z)
  ld0 = Matrix::t(R/var0)%*%(-z0)
  
  w=which(!names(theta) %in% names(parameters))
  
  J00=as.matrix(J00)
  p1=det(J)^0.5*det(Ud0)^-1*det(J[w,w])^0.5*det(J00[w,w])^-0.5*det(J00)^0.5
  p2=(t(U0)%*%solve(J00,tol=1e-200) %*% U0)^(p/2)
  p3=LR^(q/2-1)
  p4=t(ld-ld0)%*%Matrix::solve(Ud0,tol=1e-200)%*%U0
  rho=p1*p2/(p3*p4)
  LR2=LR-2*log(rho)[1,1]
  
  pv2=tryCatch(pchisq(LR2,df = q,lower.tail = F), error=function(e)NA)
  
  erro=0 + (p1<0) + 2*(p2[1,1]<0) + 3*(p3<0) + 4*(p4[1,1]<0)
  erro= paste0(1*(p1<0),1*(p2[1,1]<0),1*(p3<0),1*(p4[1,1]<0))
  out = list(LR=LR,p_value=pv, LR_correction=LR2, p_value_correction=pv2,erro=erro)
  
  class(out) = "lr_ratio"
  return(out)
}
